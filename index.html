<!-- flapy_bud_web_index.html
A single-file web version of "Flapy Bud" (Flappy Bird style).

Features:
- Responsive canvas game (desktop + mobile)
- Smooth physics, rotation, parallax background, scrolling ground
- Procedural pipes, increasing difficulty
- LocalStorage highscore
- Keyboard, mouse, touch controls
- Mute/unmute and restart controls
- Fallback drawing when images/sounds are not provided

To run: save this file as index.html and open in modern browser.
For best audio behavior, open the file via a local server (python -m http.server).

Credits: You can replace images in the assets/ folder or edit the `ASSETS` object below.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flapy Bud â€” Web</title>
  <style>
    :root{
      --bg:#87ceeb; /* sky */
      --ground:#deb887; /* sand */
      --accent:#ffcc33; /* bud */
      --pipe:#2e8b57;
      --ui-bg: rgba(0,0,0,0.4);
      --white: #ffffff;
      --muted: rgba(255,255,255,0.85);
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(var(--bg), #bfe9ff);}
    .wrap{max-width:900px;margin:18px auto;padding:10px;display:flex;gap:12px;align-items:flex-start;}
    .gamebox{flex:1;position:relative;border-radius:14px;overflow:hidden;box-shadow:0 8px 30px rgba(10,30,60,0.18);background:var(--bg)}
    canvas{display:block;width:100%;height:auto;background:transparent}
    .sidebar{width:260px;display:flex;flex-direction:column;gap:10px}

    .panel{background:var(--ui-bg);backdrop-filter:blur(6px);color:var(--white);padding:12px;border-radius:10px}
    .title{font-weight:700;font-size:20px;margin-bottom:6px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{border:0;padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.08);color:var(--white);cursor:pointer}
    button:active{transform:translateY(1px)}
    .muted{opacity:.6}
    .center{display:flex;align-items:center;justify-content:center}

    /* top overlay for messages */
    .overlay{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .message{pointer-events:auto;background:var(--ui-bg);padding:18px;border-radius:12px;color:var(--muted);text-align:center}
    .scorebig{font-size:56px;font-weight:800;color:var(--white);text-shadow:0 4px 10px rgba(0,0,0,0.4)}

    .footer{font-size:12px;color:rgba(0,0,0,0.6);text-align:center;margin-top:8px}

    @media (max-width:900px){
      .wrap{padding:8px}
      .sidebar{display:none}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="gamebox" id="gamebox">
      <canvas id="gameCanvas" width="480" height="720"></canvas>
      <div class="overlay" id="overlay">
        <div class="message" id="message" style="display:none;">
          <div id="msgTitle" style="font-weight:700;font-size:20px;margin-bottom:8px">Flapy Bud</div>
          <div id="msgBody" style="margin-bottom:8px">Press SPACE or tap to start</div>
          <div style="display:flex;gap:8px;justify-content:center">
            <button id="startBtn">Start</button>
            <button id="muteBtn">Mute</button>
          </div>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <div class="title">Flapy Bud</div>
        <div style="font-size:13px;margin-bottom:8px">A polished Flappy-Bird-style web game. Controls: Space / Click / Tap.</div>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <button id="restartBtn">Restart</button>
          <button id="fullscreenBtn">Fullscreen</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="font-size:12px;color:var(--muted)">Volume</div>
          <input type="range" id="volume" min="0" max="1" step="0.05" value="0.9" style="flex:1" />
        </div>
      </div>

      <div class="panel">
        <div class="title">Stats</div>
        <div>Score: <strong id="uiScore">0</strong></div>
        <div>Highscore: <strong id="uiHigh">0</strong></div>
        <div style="margin-top:8px;font-size:13px;color:var(--muted)">Difficulty increases over time.</div>
      </div>

      <div class="panel">
        <div class="title">About</div>
        <div style="font-size:13px;color:var(--muted)">Built with HTML5 Canvas. Open <code>index.html</code> or serve with a local server (recommended for audio).</div>
        <div style="margin-top:8px;font-size:12px;color:var(--muted)">Replace images by putting them into the same folder and editing the ASSETS object in the JS.</div>
      </div>

    </div>
  </div>
  <div class="footer">Tip: press P to pause. Built by your friendly assistant.</div>

  <script>
  // flapy_bud single-file web game
  // modern, compact, opinionated. Replace images in ASSETS or leave null for shapes.

  const ASSETS = {
    bud: null, // 'bud.png'
    pipe: null, // 'pipe.png'
    bg: null, // 'bg.png'
    ground: null, // 'ground.png'
    sounds: {
      flap: null, // 'flap.wav'
      hit: null,
      point: null
    }
  };

  // -- Config
  const CONFIG = {
    width: 480,
    height: 720,
    gravity: 0.48,
    flapStrength: -9.2,
    maxFall: 14,
    pipeGap: 160,
    pipeSpacing: 220,
    pipeBaseSpeed: 2.6,
    pipeAccel: 0.0008, // per ms
    groundHeight: 112,
    birdSize: 46
  };

  // State
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let scale = 1;
  let width = CONFIG.width, height = CONFIG.height;

  // UI elements
  const overlay = document.getElementById('overlay');
  const message = document.getElementById('message');
  const msgTitle = document.getElementById('msgTitle');
  const msgBody = document.getElementById('msgBody');
  const startBtn = document.getElementById('startBtn');
  const muteBtn = document.getElementById('muteBtn');
  const restartBtn = document.getElementById('restartBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const volumeSlider = document.getElementById('volume');
  const uiScore = document.getElementById('uiScore');
  const uiHigh = document.getElementById('uiHigh');

  // Game variables
  let running = true;
  let state = 'menu'; // menu, playing, paused, gameover
  let last = 0; // timestamp
  let bird = null;
  let pipes = [];
  let pipeTimer = 0;
  let pipeSpeed = CONFIG.pipeBaseSpeed;
  let score = 0;
  let highscore = 0;
  let groundX = 0;
  let muted = false;

  // assets: images and audio
  const images = {};
  const audio = {};

  // util: load image if ASSETS has a string name
  async function loadImage(name, src){
    if(!src) return null;
    return new Promise((res)=>{
      const img = new Image();
      img.onload = ()=>res(img);
      img.onerror = ()=>res(null);
      img.src = src;
    });
  }

  // optional: load audio (HTMLAudioElement) -- user gesture required to play on some browsers
  function loadAudio(name, src){
    if(!src) return null;
    try{
      const a = new Audio(src);
      a.preload = 'auto';
      return a;
    }catch(e){
      return null;
    }
  }

  function resizeCanvas(){
    // keep aspect ratio and fit to parent
    const box = document.getElementById('gamebox');
    const rect = box.getBoundingClientRect();
    const targetW = Math.min(rect.width, 900);
    scale = targetW / CONFIG.width;
    canvas.style.width = (CONFIG.width * scale) + 'px';
    canvas.style.height = (CONFIG.height * scale) + 'px';
    // set internal drawing size to native for crisp canvas
    canvas.width = CONFIG.width;
    canvas.height = CONFIG.height;
  }

  window.addEventListener('resize', resizeCanvas);

  // Bird class
  class Bird {
    constructor(){
      this.x = 86;
      this.y = CONFIG.height/2;
      this.vel = 0;
      this.angle = 0;
      this.size = CONFIG.birdSize;
      this.frame = 0;
      this.w = this.size; this.h = this.size;
    }
    flap(){ this.vel = CONFIG.flapStrength; }
    update(dt){
      this.vel += CONFIG.gravity * dt * 60/1000; // scale gravity per ms
      if(this.vel > CONFIG.maxFall) this.vel = CONFIG.maxFall;
      this.y += this.vel * dt * 60/1000 * 16; // scale movement
      this.angle = Math.max(-28, Math.min(80, -this.vel * 4));
      if(this.y < -50) this.y = -50;
    }
    draw(ctx){
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle * Math.PI/180);
      if(images.bud){
        ctx.drawImage(images.bud, -this.w/2, -this.h/2, this.w, this.h);
      }else{
        // fallback: circle with eye
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#ffcc33';
        roundRect(ctx, -this.w/2, -this.h/2, this.w, this.h, 10, true, false);
        ctx.fillStyle = '#fff';
        ctx.beginPath();ctx.arc(this.w*0.12, -this.h*0.12, this.w*0.09,0,Math.PI*2);ctx.fill();
      }
      ctx.restore();
    }
    getBounds(){
      return {x:this.x - this.w/2, y:this.y - this.h/2, w:this.w, h:this.h};
    }
  }

  // Pipe class
  class Pipe {
    constructor(x, gapY, speed){
      this.x = x; this.gapY = gapY; this.speed = speed; this.passed = false; this.w = 84; 
      this.topH = this.gapY - CONFIG.pipeGap/2; this.botY = this.gapY + CONFIG.pipeGap/2;
    }
    update(dt){ this.x -= this.speed * dt * 60/1000 * 16; }
    offscreen(){ return this.x < -200; }
    draw(ctx){
      if(images.pipe){
        // draw tiled pipe segments
        const segH = images.pipe.height;
        // top
        let y = this.topH - segH;
        while(y > -segH*10){ // tile enough
          ctx.drawImage(images.pipe, this.x, y, this.w, segH);
          y -= segH;
        }
        // bottom
        y = this.botY;
        while(y < CONFIG.height + segH*2){
          ctx.drawImage(images.pipe, this.x, y, this.w, segH);
          y += segH;
        }
      }else{
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe').trim() || '#2e8b57';
        ctx.fillRect(this.x, -1000, this.w, this.topH + 1000);
        ctx.fillRect(this.x, this.botY, this.w, CONFIG.height - this.botY + 1000);
      }
    }
    getTopRect(){ return {x:this.x,y: -1000,w:this.w,h:this.topH+1000}; }
    getBotRect(){ return {x:this.x,y:this.botY,w:this.w,h:1000+CONFIG.height-this.botY}; }
  }

  // helpers
  function rectsIntersect(a,b){
    return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
  }
  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if(typeof r==='undefined') r=5; if(typeof stroke==='undefined') stroke=true;
    ctx.beginPath(); ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r); ctx.closePath();
    if(fill) ctx.fill(); if(stroke) ctx.stroke();
  }

  // game functions
  function resetGame(){
    bird = new Bird();
    pipes = [];
    pipeTimer = 0;
    pipeSpeed = CONFIG.pipeBaseSpeed;
    score = 0;
    groundX = 0;
    state = 'menu';
    uiScore.textContent = score;
    uiHigh.textContent = highscore;
    showMessage('Flapy Bud', 'Press SPACE / Click / Tap to start');
  }

  function startGame(){
    state = 'playing';
    hideMessage();
    last = performance.now();
  }

  function gameOver(){
    state = 'gameover';
    if(score > highscore){ highscore = score; localStorage.setItem('flapybud_high', highscore); }
    uiHigh.textContent = highscore;
    showMessage('Game Over', `Score: ${score}`);
  }

  function spawnPipe(){
    const gapY = randInt(CONFIG.height*0.25, CONFIG.height*0.74);
    const x = CONFIG.width + 80;
    pipes.push(new Pipe(x, gapY, pipeSpeed));
  }

  function update(dt){
    if(state !== 'playing') return;
    bird.update(dt);
    pipeTimer += dt * 60/1000 * 16;
    // spawn logic: use pipeSpacing relative to speed
    if(pipeTimer > Math.max(60, 110 - (pipeSpeed-2.6)*16)){
      spawnPipe(); pipeTimer = 0;
    }
    pipes.forEach(p=>{ p.speed = pipeSpeed; p.update(dt); });
    pipes = pipes.filter(p=>!p.offscreen());

    // scoring & collision
    pipes.forEach(p=>{
      if(!p.passed && (p.x + p.w/2) < bird.x){ p.passed = true; score++; uiScore.textContent = score; if(audio.point && !muted) audio.point.play(); }
      // check collision with bird rect
      const b = bird.getBounds();
      if(rectsIntersect(b, p.getTopRect()) || rectsIntersect(b, p.getBotRect())){
        if(audio.hit && !muted) audio.hit.play();
        gameOver();
      }
    });

    // ground collision
    if(bird.y + bird.h/2 >= CONFIG.height - CONFIG.groundHeight){
      bird.y = CONFIG.height - CONFIG.groundHeight - bird.h/2;
      if(audio.hit && !muted) audio.hit.play();
      gameOver();
    }

    // increase difficulty slowly
    pipeSpeed += CONFIG.pipeAccel * dt * 60/1000 * 1000; // normalized
    groundX -= pipeSpeed * dt * 60/1000 * 16;
    const groundW = images.ground ? images.ground.width : 300;
    if(groundX <= -groundW) groundX += groundW;
  }

  function draw(){
    // clear
    ctx.clearRect(0,0,CONFIG.width,CONFIG.height);
    // background
    if(images.bg){
      const bgW = images.bg.width; const x = -((groundX*0.2)%bgW);
      for(let i=-1;i<Math.ceil(CONFIG.width/bgW)+2;i++) ctx.drawImage(images.bg, x + i*bgW, 0, bgW, CONFIG.height);
    }else{
      // sky gradient
      const g = ctx.createLinearGradient(0,0,0,CONFIG.height);
      g.addColorStop(0, '#87CEEB'); g.addColorStop(1, '#BFE9FF');
      ctx.fillStyle = g; ctx.fillRect(0,0,CONFIG.width,CONFIG.height);
    }

    // pipes
    pipes.forEach(p=>p.draw(ctx));

    // ground
    const gH = CONFIG.groundHeight;
    if(images.ground){
      const w = images.ground.width; let x = groundX;
      for(let i=0;i<Math.ceil(CONFIG.width/w)+3;i++) ctx.drawImage(images.ground, x + i*w, CONFIG.height - gH, w, gH);
    }else{
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground') || '#deb887';
      ctx.fillRect(0, CONFIG.height - gH, CONFIG.width, gH);
    }

    // bird
    bird.draw(ctx);

    // hud
    if(state === 'menu'){
      ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font = '36px system-ui'; ctx.textAlign='center'; ctx.fillText('Flapy Bud', CONFIG.width/2, 120);
    }
    if(state === 'playing'){
      ctx.font = '42px system-ui'; ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.fillText(score, CONFIG.width/2, 64);
    }
  }

  function loop(ts){
    if(!last) last = ts; const dt = ts - last; last = ts;
    update(dt);
    draw();
    if(running) requestAnimationFrame(loop);
  }

  // input
  function onFlap(){ if(state === 'menu'){ startGame(); } if(state === 'playing'){ bird.flap(); if(audio.flap && !muted) audio.flap.play(); } if(state === 'gameover'){ resetGame(); } }
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space') { e.preventDefault(); onFlap(); }
    if(e.key === 'p' || e.key === 'P'){ state = state==='playing' ? 'paused' : 'playing'; if(state==='playing') { last = performance.now(); } }
    if(e.key === 'Escape'){ /* do nothing for now */ }
  });
  canvas.addEventListener('mousedown', ()=>onFlap());
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); onFlap(); }, {passive:false});

  // UI hooks
  startBtn.addEventListener('click', ()=>{ onFlap(); });
  restartBtn.addEventListener('click', ()=>{ resetGame(); });
  muteBtn.addEventListener('click', ()=>{ muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; });
  fullscreenBtn.addEventListener('click', ()=>{ if(document.fullscreenElement) document.exitFullscreen(); else document.documentElement.requestFullscreen(); });
  volumeSlider.addEventListener('input', ()=>{ const v = parseFloat(volumeSlider.value); for(const k in audio) if(audio[k]) audio[k].volume = v; });

  function showMessage(title, body){ msgTitle.textContent = title; msgBody.textContent = body; message.style.display='block'; overlay.style.pointerEvents='auto'; }
  function hideMessage(){ message.style.display='none'; overlay.style.pointerEvents='none'; }

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  // initialization: load assets optionally
  async function init(){
    resizeCanvas();
    // load images if paths provided (ASSETS values can be relative URLs)
    images.bud = ASSETS.bud ? await loadImage('bud', ASSETS.bud) : null;
    images.pipe = ASSETS.pipe ? await loadImage('pipe', ASSETS.pipe) : null;
    images.bg = ASSETS.bg ? await loadImage('bg', ASSETS.bg) : null;
    images.ground = ASSETS.ground ? await loadImage('ground', ASSETS.ground) : null;

    audio.flap = ASSETS.sounds.flap ? loadAudio('flap', ASSETS.sounds.flap) : null;
    audio.hit  = ASSETS.sounds.hit  ? loadAudio('hit', ASSETS.sounds.hit) : null;
    audio.point= ASSETS.sounds.point? loadAudio('point', ASSETS.sounds.point) : null;

    // set volume
    const vol = parseFloat(volumeSlider.value);
    for(const k in audio) if(audio[k]) audio[k].volume = vol;

    // highscore
    highscore = parseInt(localStorage.getItem('flapybud_high')||0,10);
    uiHigh.textContent = highscore;

    resetGame();
    requestAnimationFrame(loop);
  }

  // Start when DOM ready
  document.addEventListener('DOMContentLoaded', ()=>init());

  // Helpful: allow drag-drop of images into the canvas to auto-use them
  canvas.addEventListener('dragover', e=>e.preventDefault());
  canvas.addEventListener('drop', async (e)=>{
    e.preventDefault(); const f = e.dataTransfer.files[0]; if(!f) return; const name = f.name.toLowerCase();
    const url = URL.createObjectURL(f);
    if(name.includes('bud')){ images.bud = await loadImage('bud', url);} else if(name.includes('pipe')){ images.pipe = await loadImage('pipe', url);} else if(name.includes('ground')){ images.ground = await loadImage('ground', url);} else if(name.includes('bg')){ images.bg = await loadImage('bg', url);} else {
      // auto assign by extension guess
      if(f.type.startsWith('image')) images.bud = await loadImage('img', url);
    }
  });

  </script>
</body>
</html>
